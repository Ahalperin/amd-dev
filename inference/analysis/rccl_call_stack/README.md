# NCCL Call Stack Analyzer

This script analyzes Perfetto trace files to find the call stacks where NCCL kernels were launched from. It uses SQL queries to trace GPU kernel launches back to their originating CPU call sites through flow events.

## Setup

### Environment Setup

It is recommended to use a Python virtual environment to isolate dependencies:

```bash
# Create a virtual environment
python3 -m virtualenv ~/my_pyenv

# Activate the virtual environment
source ~/my_pyenv/bin/activate
```

### Installing Dependencies

Once the virtual environment is activated, install the required dependencies:

```bash
pip install -r requirements.txt
```

## Trace Generation

The script expects Perfetto trace files (`.trace.json.gz` format) that contain profiling data from SGLang runs.

### Generating Traces

Traces are typically generated by running SGLang with the `--profile` flag. Currently, traces can be generated using the `start_server_container.sh` script in benchmark mode:

```bash
./start_server_container.sh benchmark [OPTIONS]
```

This will run SGLang with profiling enabled and generate trace files in the `outputs/sglang_profile/` directory.

## Usage

```bash
python get_call_stacks.py <trace_file> [options]
```

### Arguments

- `trace_file` (required): Path to the Perfetto trace file (.perfetto-trace or .pb)

### Examples

Basic usage with default function name (will interactively ask to select a slice):

```bash
python get_call_stacks.py trace.perfetto-trace
```

Specify a function name and use a specific slice index:

```bash
python get_call_stacks.py trace.perfetto-trace \
    --function-name "/path/to/file.py(123): function_name" \
    --index 0
```

Use custom timestamp range (overrides function-based selection):

```bash
python get_call_stacks.py trace.perfetto-trace \
    --start-ts 6073953868955133 \
    --duration 77565242
```

Specify a different kernel name and stack depth:

```bash
python get_call_stacks.py trace.perfetto-trace \
    --kernel-name "ncclDevKernel_AllReduce" \
    --stack-depth 15
```

Save results to a file:

```bash
python get_call_stacks.py trace.perfetto-trace --output call_stacks.txt
```

## How It Works

The script works in two main phases:

### Phase 1: Time Window Selection

The script can determine the analysis time window in two ways:

1. **Function-based (default)**: Searches for CPU slices matching a specified function name. If multiple matches are found, it either uses the `--index` parameter or interactively prompts the user to select one. The selected slice's timestamp and duration define the analysis window.

2. **Direct timestamps**: If both `--start-ts` and `--duration` are provided, they override the function-based selection.

### Phase 2: Call Stack Analysis

Once the time window is determined, the script:

1. Finds GPU kernel slices matching the specified kernel name within the time window
2. Uses flow events to trace back to the CPU slices that launched them
3. Recursively builds the call stack by following parent relationships (up to `--stack-depth` levels, default: 12)
4. Groups identical call stacks and counts their occurrences
5. Outputs the results sorted by frequency

### When No Results Are Found

If no call stacks are found, the script will:

- Check if the target kernel exists in the trace during the time window
- If found, indicate that it was likely launched as part of a graph without tracking data
- If not found, show a filtered list of relevant kernels (containing keywords like 'nccl', 'reduce', 'gather', 'broadcast', or 'scatter')

## Output Format

The output shows each unique call stack with:
- **Call Stack**: The function call chain from the top-level function down to the kernel launch, with each level on a separate line
- **Count**: Number of times this call stack was observed

Example output:

```
function_a
 ->
function_b
 ->
function_c
 ->
ncclLaunchKernel
Appeared 15 times

function_a
 ->
function_d
 ->
ncclLaunchKernel
Appeared 8 times
```

